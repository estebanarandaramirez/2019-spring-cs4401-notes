---
author: Esteban Aranda
---

##Quick Notes: Heap Metadata

Let's take a look at how a chunks of heap memory are structured:
```
#define INTERNAL_SIZE_T size_t

struct malloc_chunk 
   {
    INTERNAL_SIZE_T prev_size;
    INTERNAL_SIZE_T size;
    struct malloc_chunk * fd;
    struct malloc_chunk * bk;
   };
 ```
`prev_size` contains the size of the previous chunk, and it is only used if the previous chunk is free. 
`size` contains the size of the current chunk (including overhead), and it's lowest 3 bits are always free since malloc chunks are always multiples of 8 bytes. These 3 lowest bits are used to set flags `A`, `M`, and `P`. `A` for `NON_MAIN_AREA`, `M` for `IS_MMAPED`, and `P` for `PREV_INUSE`.
`fd` and `bk` are pointers to the next and previous free chunks respectively, used to keep track of free chunks in a doubly linked list. Only used if the current chunk is free.

Allocated chunk:
`
chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of chunk, in bytes                     |A|M|P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             User data starts here...                          .
            .                                                               .
            .             (malloc_usable_size() bytes)                      .
            .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             (size of chunk, but used for application data)    |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|1|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
`
Free chunk:
`
chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:' |             Size of chunk, in bytes                     |A|0|P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Forward pointer to next chunk in list             |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk in list            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space (may be 0 bytes long)                .
            .                                                               .
            .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:' |             Size of chunk, in bytes                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|0|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
`

Important: When chunks are freed, they get stored into different bins depending on the size of the chunk. Each bin mantains it's own doubly-linked list. So, to if we are trying to exploit a binary we want all the chunks to be treated in the same way to ensure that they will be pointing to each other.

Using the properites of malloc chunks, we can exploit them via `unlink()` which is called by `free()` in specific scenarios:
`
[4.1] -- If the chunk located immediately before the chunk to be freed
is unused, it is taken off its doubly-linked list via unlink() (if it is
not the `last_remainder') and consolidated with the chunk being freed.

[4.2] -- If the chunk located immediately after the chunk to be freed is
unused, it is taken off its doubly-linked list via unlink() (if it is
not the `last_remainder') and consolidated with the chunk being freed.
`

The `unlink()` macro is defined as following:
`
#define unlink(P, BK, FD)                                                \
{                                                                        \
  BK = P->bk;                                                            \
  FD = P->fd;                                                            \
  FD->bk = BK;                                                           \
  BK->fd = FD;                                                           \
}
`
`P` is the current chunk and `FD` and `BK` are temporary pointers. 'unlink()` basically performs two functions:
1- It writes the value of `P->bk` to the address pointed to by `(P->fd)+12`.
2- It writes the value of `P->fd` to the address pointed to by `(P->bk)+8`.
Essentially, `P` is removed from the list and `FD` and `BK` point to eachother.

If we are able to control the values of `P->fd` and `P->bk` at the moment of `unlink()`, then we can we will have a write-what-where.

Sources:
http://phrack.org/issues/57/8.html 
http://phrack.org/issues/57/9.html
https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/malloc_chunk.html
https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/bins_chunks.html
http://garage4hackers.com/showthread.php?t=1691
